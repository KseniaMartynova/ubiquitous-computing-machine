# Сравнение производительности библиотек линейной алгебры для обращения положительно определенных матриц
## Содержание
- [Введение](#Введение)
- [MKL](#Intel_Math_Kernel_Library (MKL))
- [OpenBLAS - LAPACK](#OpenBLAS_-_LAPACK)
- [NumPy](#NumPy)
- [Eigen](#Eigen)
- [Armadillo](#Armadillo)
- [CUDA cuBLAS и cuSOLVER](#CUDA_cuBLAS_и_cuSOLVER)
- [Результаты](#Результаты)

## Введение
Этот репозиторий создан и стал открытым и общедоступным для того, чтобы любой желающий и облающий минимальными компетенциями в работе с Linux системами, мог воспроизвести все наши вычисления и сделать собственные выводы.
Стоит сказать, что работа со следующими библиотеками:Eigen, Armadillo, CUDA cuBLAS и cuSOLVER - не вошла в итоговую статью, потому что библиотеки либо устаревшие, либо работают про принципу MKL. Все наработки по этим библиотекам сохранены в папке [draft](draft) и читатель может продолжить нашу работу и вывести закономерности самотоятельно.  

(для запуска: bash run_lapack.sh | tee -a result_openBLAS_LAPACK_docker.log)
## Intel Math Kernel Library (MKL)
Библиотека Intel Math Kernel Library (MKL) — это набор высокопроизводительных математических функций, оптимизированных для работы на процессорах Intel. 

- MKL предоставляет функции для линейной алгебры, быстрого преобразования Фурье, математических функций, статистики и других задач. 
- Эта библиотека поддерживает многопоточность, что позволяет эффективно использовать многоядерные процессоры. Функции MKL автоматически распределяют вычисления между ядрами, что уменьшает время выполнения задач.
- Может быть использована в сочетании с другими библиотеками, такими как BLAS (Basic Linear Algebra Subprograms), LAPACK (Linear Algebra Package), FFTW (Fastest Fourier Transform in the West) и другими. Это обеспечивает высокую производительность и совместимость.

Я запускаю все на таком то железе, с такой то убутной и таким то докером.

1. Итак, скачаем образ из официального dockerhub intel.
```
docker pull intel/oneapi-basekit
```
2. Далее создадим dockerfile, в котором содержится все, что нам нужно для дальнейших вычислений, например, сама программа, которая производит обращение положительно определенной матрицы и замеряет время ее обращения.
```
docker build -t intel/oneapi-basekit:latest -f Dockerfile.mkl .
```
3. Для единичного запуска программы мы можем запустить контейнер и внутри уже ввести размер матрицы.
```
docker run --rm -ti -v mkl:/usr/share intel/oneapi-basekit:latest bash

./mkl
```
Вместо третьего пункта на самом деле можно сделать следующее и сразу ввести размер матрицы, не заходя в контейнер:
```
docker run intel/oneapi-basekit 200
```
Для более точного результата лучше несколько раз подсчитать время обращения матрицы. Напишем скрипт на shell. Он десять раз запускает контейнер и записывает результаты в файл.
Вот запуск этого скрипта:
```
bash mkrun.sh | tee -a resmkl.txt
```
Результаты представлены в самом низу. 

![image](https://github.com/user-attachments/assets/548f12dd-041b-474c-a4e1-e538c6dee991)

## OpenBLAS_-_LAPACK
LAPACK (Linear Algebra Package). 

- LAPACK предоставляет набор функций для решения систем линейных уравнений, разложения матриц (например, LU, QR, SVD), решения задач на собственные значения и векторы, а также для других операций с матрицами.
- часто используется в сочетании с BLAS (Basic Linear Algebra Subprograms), которые предоставляют низкоуровневые операции линейной алгебры. Это позволяет оптимизировать производительность за счет использования специализированных библиотек BLAS, таких как OpenBLAS.

OpenBLAS (Open Basic Linear Algebra Subprograms).

- OpenBLAS — это оптимизированная реализация BLAS, которая использует многопоточность, SIMD (Single Instruction, Multiple Data) инструкции и другие методы для повышения производительности.
  
Для использования LAPACK и OpenBLAS вместе, обычно необходимо сначала установить OpenBLAS, а затем сконфигурировать и установить LAPACK так, чтобы он использовал OpenBLAS в качестве библиотеки BLAS. 

1. Итак, построим образ с помощью dockerfile, в который мы предварительно положим пакеты для устновки lapack и openblas.
```
docker build -t lapack:latest -f Dockerfile.lablas .
```
2. Далее можно запустить контейнер с нужным размером матрицы, матрица обратится, и мы узнаем время ее обращения.
```
docker run lapack  200
```
Но здесь нам тоже нужно будет несколько раз запустить обращение матрицы для более точного результата. Поэтому запустим скрипт, он какой же как для mkl.
```
bash larun.sh | tee -a reslablas.txt
```
Разультаты представлены в самом низу.

![image](https://github.com/user-attachments/assets/10aaa2e4-12e2-46af-b0bd-0d0dfadc5336)

## NumPy
- NumPy предоставляет мощные возможности для индексирования и среза массивов, включая многомерное индексирование, логическое индексирование и комбинированные срезы.
- NumPy легко интегрируется с другими научными библиотеками Python, такими как SciPy, pandas, matplotlib и scikit-learn. Это делает её ключевым компонентом экосистемы научных вычислений в Python.

1. В dockerfile внесем numpy и запустим сборку.
```
docker build -t num:latest -f Dockerfile.num .
```
2. Единичный запуск с нужным размером матрицы.
```
docker run num 200
```
И с помощью скрипта сделаем несколько запусков:
```
bash numrun.sh | tee -a resnum.txt
```
![image](https://github.com/user-attachments/assets/ceb46548-4d0d-47fd-bb38-b89180d8307b)

## Eigen
Eigen — это C++ библиотека для линейной алгебры, которая предоставляет высокопроизводительные и легковесные решения для работы с матрицами и векторами. 
- Eigen использует мощь шаблонов C++ для обеспечения высокой производительности и гибкости. Это позволяет компилятору генерировать оптимизированный код для конкретных типов данных и размеров матриц, что приводит к уменьшению накладных расходов во время выполнения.
- Eigen реализован полностью в заголовочных файлах (header-only), что упрощает его интеграцию в проекты. Нет необходимости в отдельной компиляции или линковке библиотеки, достаточно просто включить соответствующие заголовочные файлы в ваш код.
- Eigen не зависит от других библиотек, что упрощает его использование и распространение.

Очень полезная ссылка для пошаговой установки eigen: https://www.cyberithub.com/how-to-install-eigen3-on-ubuntu-20-04-lts-focal-fossa/

1. Поместим все шаги установки по ссылке выше в наш doсkerfile и построим образ.
```
docker build -t eigen:latest -f Dockerfile.Eigen .
```
2. После окончания загрузки можем запустить контейнер с нужным размером матрицы. В результате получим время обращения матрицы и корректность выполенения операции.
```
docker run eigen 200
```
И снова используем скрипт, который 10 раз запустит обращение матрицы нужного нам размера и запишет результаты в файл.
```
bash eirun.sh | tee -a resei.txt
```
Результаты запуска на таком то железе, с такой то убунтой и докером представлены внизу.

![image](https://github.com/user-attachments/assets/83d79fc8-e46b-453e-983d-b7e45516de7e)

## Armadillo
Библиотека Armadillo — это высокопроизводительная C++ библиотека для линейной алгебры, которая предоставляет удобный интерфейс для работы с матрицами и векторами.

- Armadillo включает в себя множество оптимизаций для повышения производительности. Например, она использует вызовы BLAS и LAPACK для критически важных операций, что позволяет использовать высокооптимизированные библиотеки для линейной алгебры.
- Библиотека поддерживает широкий спектр операций, включая матричные и векторные операции, решение линейных систем, сингулярное разложение, собственные значения и векторы, QR и LU разложения и многое другое.
- Armadillo может быть легко интегрирована с другими библиотеками, такими как OpenBLAS, Intel MKL, и другими, что позволяет ей использовать их оптимизированные функции для повышения производительности.

Ссылка для обычной пошаговой установки: https://solarianprogrammer.com/2017/03/24/getting-started-armadillo-cpp-linear-algebra-windows-mac-linux/

1. Запустим armadillo в docker контейнере с помощью dockerfile, в который мы поместили все нужное.
```
docker build -t armadillo:latest -f Dockerfile.arm .

docker run armadillo 200
```
Так как нам нужно запустить его несколько раз и записать результаты запуска в файл, воспользуемся скриптом:
```
bash armrun.sh | tee -a resarm.txt
```

![armadillo](https://github.com/user-attachments/assets/9dc4e79c-1797-4879-9938-c4a4dbde961b)


## CUDA_cuBLAS_и_cuSOLVER
```
docker build -t cudaks -f Dockerfile.cuda .
```
2. Единичный запуск с нужным размером матрицы.
```
docker run cudaks 200
```
И с помощью скрипта сделаем несколько запусков:
```
bash cudarun.sh | tee -a rescuda.txt
```
## Результаты















